[{"path":"https://camaradesuk.github.io/ASySD/articles/basic-deduplication.html","id":"automated-deduplication","dir":"Articles","previous_headings":"","what":"Automated deduplication","title":"Simple Deduplication","text":"Remove duplicate citations automatically using dedup_citations function. dedup_citations function returns list two dataframes default. first contains unique citations duplicates removed automatically ASySD. cases, remove vast majority duplicates. likely duplicates remaining need manual review human (see next step).","code":"results <- dedup_citations(citations) #> formatting data... #> Called from: dedup_citations(citations) #> debug: raw_citations <- raw_citations %>% mutate(across(where(is.character),  #>     ~na_if(., \"\"))) %>% mutate(label = ifelse(is.na(label), \"unknown\",  #>     paste(label))) %>% mutate(source = ifelse(is.na(source),  #>     \"unknown\", paste(source))) %>% mutate(across({ #>     { #>         extra_merge_fields #>     } #> }, ~replace(., is.na(.), \"unknown\"))) #> debug: if (!\"record_id\" %in% names(raw_citations)) { #>     warning(\"Search does not contain a record_id column. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } else if (any(is.na(raw_citations$record_id)) | any(raw_citations$record_id ==  #>     \"\")) { #>     warning(\"Search contains missing values for the record_id column. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } else if (length(unique(raw_citations$record_id)) != nrow(raw_citations)) { #>     warning(\"The record_id column is not unique. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } #> debug: if (any(is.na(raw_citations$record_id)) | any(raw_citations$record_id ==  #>     \"\")) { #>     warning(\"Search contains missing values for the record_id column. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } else if (length(unique(raw_citations$record_id)) != nrow(raw_citations)) { #>     warning(\"The record_id column is not unique. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } #> debug: if (length(unique(raw_citations$record_id)) != nrow(raw_citations)) { #>     warning(\"The record_id column is not unique. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } #> debug: cols <- c(\"author\", \"year\", \"journal\", \"doi\", \"title\", \"pages\",  #>     \"volume\", \"number\", \"abstract\", \"record_id\", \"isbn\", \"label\",  #>     \"source\") #> debug: missing_cols <- cols[!(cols %in% colnames(raw_citations))] #> debug: if (length(missing_cols) > 0) { #>     warning(paste0(\"The following columns are missing: \", paste(missing_cols,  #>         collapse = \", \"), \"\\n\")) #>     message(paste0(\"Setting missing cols to NA\")) #> } #> debug: raw_citations[missing_cols] <- NA #> debug: raw_citations$record_id <- as.character(raw_citations$record_id) #> debug: ordered_citations <- order_citations(raw_citations) #> debug: formatted_citations <- format_citations(ordered_citations) #> debug: message(\"identifying potential duplicates...\") #> identifying potential duplicates... #> debug: pairs <- match_citations(formatted_citations) #> debug: if (is.null(pairs)) { #>     warning(\"No duplicates detected!\") #>     return(raw_citations) #> } #> debug: pair_types <- identify_true_matches(pairs) #> debug: true_pairs <- pair_types$true_pairs #> debug: if (is.null(true_pairs)) { #>     warning(\"No duplicates detected!\") #>     return(raw_citations) #> } #> debug: message(\"identified duplicates!\") #> identified duplicates! #> debug: matched_pairs_with_ids <- generate_dup_id(true_pairs, formatted_citations) #> debug: if (manual_dedup == TRUE) { #>     message(\"flagging potential pairs for manual dedup...\") #>     maybe_pairs <- pair_types$maybe_pairs #>     maybe_pairs <- maybe_pairs %>% mutate(author1 = ordered_citations$author[id1]) %>%  #>         mutate(author2 = ordered_citations$author[id2]) %>% mutate(title1 = ordered_citations$title[id1]) %>%  #>         mutate(title2 = ordered_citations$title[id2]) %>% mutate(abstract1 = ordered_citations$abstract[id1]) %>%  #>         mutate(abstract2 = ordered_citations$abstract[id2]) %>%  #>         mutate(doi1 = ordered_citations$doi[id1]) %>% mutate(doi2 = ordered_citations$doi[id2]) %>%  #>         mutate(year1 = ordered_citations$year[id1]) %>% mutate(year2 = ordered_citations$year[id2]) %>%  #>         mutate(number1 = ordered_citations$number[id1]) %>% mutate(number2 = ordered_citations$number[id2]) %>%  #>         mutate(pages1 = ordered_citations$pages[id1]) %>% mutate(pages2 = ordered_citations$pages[id2]) %>%  #>         mutate(volume1 = ordered_citations$volume[id1]) %>% mutate(volume2 = ordered_citations$volume[id2]) %>%  #>         mutate(journal1 = ordered_citations$journal[id1]) %>%  #>         mutate(journal2 = ordered_citations$journal[id2]) %>%  #>         mutate(isbn1 = ordered_citations$isbn[id1]) %>% mutate(isbn2 = ordered_citations$isbn[id2]) %>%  #>         mutate(record_id1 = ordered_citations$record_id[id1]) %>%  #>         mutate(record_id2 = ordered_citations$record_id[id2]) %>%  #>         mutate(label1 = ordered_citations$label[id1]) %>% mutate(label2 = ordered_citations$label[id2]) %>%  #>         mutate(source1 = ordered_citations$source[id1]) %>% mutate(source2 = ordered_citations$source[id2]) %>%  #>         select(author1, author2, author, title1, title2, title,  #>             abstract1, abstract2, abstract, year1, year2, year,  #>             number1, number2, number, pages1, pages2, pages,  #>             volume1, volume2, volume, journal1, journal2, journal,  #>             isbn, isbn1, isbn2, doi1, doi2, doi, record_id1,  #>             record_id2, label1, label2, source1, source2) #>     manual_dedup <- maybe_pairs #> } #> debug: message(\"flagging potential pairs for manual dedup...\") #> flagging potential pairs for manual dedup... #> debug: maybe_pairs <- pair_types$maybe_pairs #> debug: maybe_pairs <- maybe_pairs %>% mutate(author1 = ordered_citations$author[id1]) %>%  #>     mutate(author2 = ordered_citations$author[id2]) %>% mutate(title1 = ordered_citations$title[id1]) %>%  #>     mutate(title2 = ordered_citations$title[id2]) %>% mutate(abstract1 = ordered_citations$abstract[id1]) %>%  #>     mutate(abstract2 = ordered_citations$abstract[id2]) %>% mutate(doi1 = ordered_citations$doi[id1]) %>%  #>     mutate(doi2 = ordered_citations$doi[id2]) %>% mutate(year1 = ordered_citations$year[id1]) %>%  #>     mutate(year2 = ordered_citations$year[id2]) %>% mutate(number1 = ordered_citations$number[id1]) %>%  #>     mutate(number2 = ordered_citations$number[id2]) %>% mutate(pages1 = ordered_citations$pages[id1]) %>%  #>     mutate(pages2 = ordered_citations$pages[id2]) %>% mutate(volume1 = ordered_citations$volume[id1]) %>%  #>     mutate(volume2 = ordered_citations$volume[id2]) %>% mutate(journal1 = ordered_citations$journal[id1]) %>%  #>     mutate(journal2 = ordered_citations$journal[id2]) %>% mutate(isbn1 = ordered_citations$isbn[id1]) %>%  #>     mutate(isbn2 = ordered_citations$isbn[id2]) %>% mutate(record_id1 = ordered_citations$record_id[id1]) %>%  #>     mutate(record_id2 = ordered_citations$record_id[id2]) %>%  #>     mutate(label1 = ordered_citations$label[id1]) %>% mutate(label2 = ordered_citations$label[id2]) %>%  #>     mutate(source1 = ordered_citations$source[id1]) %>% mutate(source2 = ordered_citations$source[id2]) %>%  #>     select(author1, author2, author, title1, title2, title, abstract1,  #>         abstract2, abstract, year1, year2, year, number1, number2,  #>         number, pages1, pages2, pages, volume1, volume2, volume,  #>         journal1, journal2, journal, isbn, isbn1, isbn2, doi1,  #>         doi2, doi, record_id1, record_id2, label1, label2, source1,  #>         source2) #> debug: manual_dedup <- maybe_pairs #> debug: if (merge_citations == TRUE) { #>     unique_citations_with_metadata <- merge_metadata(raw_citations,  #>         matched_pairs_with_ids, keep_source, keep_label, extra_merge_fields) #> } else { #>     unique_citations_with_metadata <- keep_one_unique_citation(raw_citations,  #>         matched_pairs_with_ids, keep_source, keep_label) #> } #> debug: unique_citations_with_metadata <- keep_one_unique_citation(raw_citations,  #>     matched_pairs_with_ids, keep_source, keep_label) #> debug: unique_citations_with_metadata <- unique_citations_with_metadata %>%  #>     ungroup() #> debug: n_unique <- length(unique(unique_citations_with_metadata$duplicate_id)) #> debug: n_start <- length(unique(formatted_citations$record_id)) #> debug: n_dups <- n_start - n_unique #> debug: message(paste(n_start, \"citations loaded...\")) #> 8948 citations loaded... #> debug: message(paste(n_dups, \"duplicate citations removed...\")) #> 3508 duplicate citations removed... #> debug: message(paste(n_unique, \"unique citations remaining!\")) #> 5440 unique citations remaining! #> debug: return(list(unique = unique_citations_with_metadata, manual_dedup = manual_dedup)) unique_citations <- results$unique"},{"path":"https://camaradesuk.github.io/ASySD/articles/basic-deduplication.html","id":"manual-deduplication","dir":"Articles","previous_headings":"","what":"Manual deduplication","title":"Simple Deduplication","text":"check additional duplicates, get dataframe citations manual review. can review within R export csv / excel file go row pairs. reviewing pairs, create dataframe contianing true duplicate pairs. , simplicity, retained subset potential_duplicates dataframe. exported file, remove rows duplicates re-upload rows true duplicates. Now, get final deduplication results, use dedup_citations_add_manual()function. account additional duplicates reviewed, add additional_pairs argument.","code":"potential_duplicates <- results$manual_dedup true_duplicates <- potential_duplicates[1:16,] final_results <- dedup_citations_add_manual(citations, additional_pairs = true_duplicates) #> formatting data... #> identifying potential duplicates... #> identified duplicates! #> 8948 citations loaded... #> 3519 duplicate citations removed... #> 5429 unique citations remaining!"},{"path":"https://camaradesuk.github.io/ASySD/articles/search-updates.html","id":"combine-citations","dir":"Articles","previous_headings":"","what":"Combine citations","title":"Updating a Systematic Search","text":"deduplication, must bind citations one dataframe. First, give search different source can specify citations retain.","code":"existing_search$source <- \"old\" new_search$source <- \"new\"  all_citations <- plyr::rbind.fill(existing_search, new_search)"},{"path":"https://camaradesuk.github.io/ASySD/articles/search-updates.html","id":"automated-deduplication","dir":"Articles","previous_headings":"","what":"Automated deduplication","title":"Updating a Systematic Search","text":"Remove duplicate citations automatically using dedup_citations function. specified argument merge=TRUE indicate want merge duplicate records record citations merged one. specified keep_source argument wish preferentially retain old citations. practice, means duplicate_id chosen set records preferentially record_id citation OLD systematic search. facilitate easy record linkage - see later. dedup_citations function returns list two dataframes default. first contains unique citations duplicates removed automatically ASySD. cases, remove vast majority duplicates. likely duplicates remaining need manual review human (see next step).","code":"results <- dedup_citations(all_citations, merge=TRUE, keep_source = \"old\") #> formatting data... #> Called from: dedup_citations(all_citations, merge = TRUE, keep_source = \"old\") #> debug: raw_citations <- raw_citations %>% mutate(across(where(is.character),  #>     ~na_if(., \"\"))) %>% mutate(label = ifelse(is.na(label), \"unknown\",  #>     paste(label))) %>% mutate(source = ifelse(is.na(source),  #>     \"unknown\", paste(source))) %>% mutate(across({ #>     { #>         extra_merge_fields #>     } #> }, ~replace(., is.na(.), \"unknown\"))) #> debug: if (!\"record_id\" %in% names(raw_citations)) { #>     warning(\"Search does not contain a record_id column. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } else if (any(is.na(raw_citations$record_id)) | any(raw_citations$record_id ==  #>     \"\")) { #>     warning(\"Search contains missing values for the record_id column. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } else if (length(unique(raw_citations$record_id)) != nrow(raw_citations)) { #>     warning(\"The record_id column is not unique. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } #> debug: if (any(is.na(raw_citations$record_id)) | any(raw_citations$record_id ==  #>     \"\")) { #>     warning(\"Search contains missing values for the record_id column. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } else if (length(unique(raw_citations$record_id)) != nrow(raw_citations)) { #>     warning(\"The record_id column is not unique. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } #> debug: if (length(unique(raw_citations$record_id)) != nrow(raw_citations)) { #>     warning(\"The record_id column is not unique. A record_id will be created using row names\") #>     raw_citations <- add_id_citations(raw_citations) #> } #> debug: cols <- c(\"author\", \"year\", \"journal\", \"doi\", \"title\", \"pages\",  #>     \"volume\", \"number\", \"abstract\", \"record_id\", \"isbn\", \"label\",  #>     \"source\") #> debug: missing_cols <- cols[!(cols %in% colnames(raw_citations))] #> debug: if (length(missing_cols) > 0) { #>     warning(paste0(\"The following columns are missing: \", paste(missing_cols,  #>         collapse = \", \"), \"\\n\")) #>     message(paste0(\"Setting missing cols to NA\")) #> } #> debug: raw_citations[missing_cols] <- NA #> debug: raw_citations$record_id <- as.character(raw_citations$record_id) #> debug: ordered_citations <- order_citations(raw_citations) #> debug: formatted_citations <- format_citations(ordered_citations) #> debug: message(\"identifying potential duplicates...\") #> identifying potential duplicates... #> debug: pairs <- match_citations(formatted_citations) #> debug: if (is.null(pairs)) { #>     warning(\"No duplicates detected!\") #>     return(raw_citations) #> } #> debug: pair_types <- identify_true_matches(pairs) #> debug: true_pairs <- pair_types$true_pairs #> debug: if (is.null(true_pairs)) { #>     warning(\"No duplicates detected!\") #>     return(raw_citations) #> } #> debug: message(\"identified duplicates!\") #> identified duplicates! #> debug: matched_pairs_with_ids <- generate_dup_id(true_pairs, formatted_citations) #> debug: if (manual_dedup == TRUE) { #>     message(\"flagging potential pairs for manual dedup...\") #>     maybe_pairs <- pair_types$maybe_pairs #>     maybe_pairs <- maybe_pairs %>% mutate(author1 = ordered_citations$author[id1]) %>%  #>         mutate(author2 = ordered_citations$author[id2]) %>% mutate(title1 = ordered_citations$title[id1]) %>%  #>         mutate(title2 = ordered_citations$title[id2]) %>% mutate(abstract1 = ordered_citations$abstract[id1]) %>%  #>         mutate(abstract2 = ordered_citations$abstract[id2]) %>%  #>         mutate(doi1 = ordered_citations$doi[id1]) %>% mutate(doi2 = ordered_citations$doi[id2]) %>%  #>         mutate(year1 = ordered_citations$year[id1]) %>% mutate(year2 = ordered_citations$year[id2]) %>%  #>         mutate(number1 = ordered_citations$number[id1]) %>% mutate(number2 = ordered_citations$number[id2]) %>%  #>         mutate(pages1 = ordered_citations$pages[id1]) %>% mutate(pages2 = ordered_citations$pages[id2]) %>%  #>         mutate(volume1 = ordered_citations$volume[id1]) %>% mutate(volume2 = ordered_citations$volume[id2]) %>%  #>         mutate(journal1 = ordered_citations$journal[id1]) %>%  #>         mutate(journal2 = ordered_citations$journal[id2]) %>%  #>         mutate(isbn1 = ordered_citations$isbn[id1]) %>% mutate(isbn2 = ordered_citations$isbn[id2]) %>%  #>         mutate(record_id1 = ordered_citations$record_id[id1]) %>%  #>         mutate(record_id2 = ordered_citations$record_id[id2]) %>%  #>         mutate(label1 = ordered_citations$label[id1]) %>% mutate(label2 = ordered_citations$label[id2]) %>%  #>         mutate(source1 = ordered_citations$source[id1]) %>% mutate(source2 = ordered_citations$source[id2]) %>%  #>         select(author1, author2, author, title1, title2, title,  #>             abstract1, abstract2, abstract, year1, year2, year,  #>             number1, number2, number, pages1, pages2, pages,  #>             volume1, volume2, volume, journal1, journal2, journal,  #>             isbn, isbn1, isbn2, doi1, doi2, doi, record_id1,  #>             record_id2, label1, label2, source1, source2) #>     manual_dedup <- maybe_pairs #> } #> debug: message(\"flagging potential pairs for manual dedup...\") #> flagging potential pairs for manual dedup... #> debug: maybe_pairs <- pair_types$maybe_pairs #> debug: maybe_pairs <- maybe_pairs %>% mutate(author1 = ordered_citations$author[id1]) %>%  #>     mutate(author2 = ordered_citations$author[id2]) %>% mutate(title1 = ordered_citations$title[id1]) %>%  #>     mutate(title2 = ordered_citations$title[id2]) %>% mutate(abstract1 = ordered_citations$abstract[id1]) %>%  #>     mutate(abstract2 = ordered_citations$abstract[id2]) %>% mutate(doi1 = ordered_citations$doi[id1]) %>%  #>     mutate(doi2 = ordered_citations$doi[id2]) %>% mutate(year1 = ordered_citations$year[id1]) %>%  #>     mutate(year2 = ordered_citations$year[id2]) %>% mutate(number1 = ordered_citations$number[id1]) %>%  #>     mutate(number2 = ordered_citations$number[id2]) %>% mutate(pages1 = ordered_citations$pages[id1]) %>%  #>     mutate(pages2 = ordered_citations$pages[id2]) %>% mutate(volume1 = ordered_citations$volume[id1]) %>%  #>     mutate(volume2 = ordered_citations$volume[id2]) %>% mutate(journal1 = ordered_citations$journal[id1]) %>%  #>     mutate(journal2 = ordered_citations$journal[id2]) %>% mutate(isbn1 = ordered_citations$isbn[id1]) %>%  #>     mutate(isbn2 = ordered_citations$isbn[id2]) %>% mutate(record_id1 = ordered_citations$record_id[id1]) %>%  #>     mutate(record_id2 = ordered_citations$record_id[id2]) %>%  #>     mutate(label1 = ordered_citations$label[id1]) %>% mutate(label2 = ordered_citations$label[id2]) %>%  #>     mutate(source1 = ordered_citations$source[id1]) %>% mutate(source2 = ordered_citations$source[id2]) %>%  #>     select(author1, author2, author, title1, title2, title, abstract1,  #>         abstract2, abstract, year1, year2, year, number1, number2,  #>         number, pages1, pages2, pages, volume1, volume2, volume,  #>         journal1, journal2, journal, isbn, isbn1, isbn2, doi1,  #>         doi2, doi, record_id1, record_id2, label1, label2, source1,  #>         source2) #> debug: manual_dedup <- maybe_pairs #> debug: if (merge_citations == TRUE) { #>     unique_citations_with_metadata <- merge_metadata(raw_citations,  #>         matched_pairs_with_ids, keep_source, keep_label, extra_merge_fields) #> } else { #>     unique_citations_with_metadata <- keep_one_unique_citation(raw_citations,  #>         matched_pairs_with_ids, keep_source, keep_label) #> } #> debug: unique_citations_with_metadata <- merge_metadata(raw_citations,  #>     matched_pairs_with_ids, keep_source, keep_label, extra_merge_fields) #> debug: unique_citations_with_metadata <- unique_citations_with_metadata %>%  #>     ungroup() #> debug: n_unique <- length(unique(unique_citations_with_metadata$duplicate_id)) #> debug: n_start <- length(unique(formatted_citations$record_id)) #> debug: n_dups <- n_start - n_unique #> debug: message(paste(n_start, \"citations loaded...\")) #> 8972 citations loaded... #> debug: message(paste(n_dups, \"duplicate citations removed...\")) #> 472 duplicate citations removed... #> debug: message(paste(n_unique, \"unique citations remaining!\")) #> 8500 unique citations remaining! #> debug: return(list(unique = unique_citations_with_metadata, manual_dedup = manual_dedup)) unique_citations <- results$unique"},{"path":"https://camaradesuk.github.io/ASySD/articles/search-updates.html","id":"manual-deduplication","dir":"Articles","previous_headings":"","what":"Manual deduplication","title":"Updating a Systematic Search","text":"check additional duplicates, get dataframe citations manual review. can review within R export csv / excel file go row pairs. reviewing pairs, create dataframe contianing true duplicate pairs. , suggested duplicates look like REAL duplicates. exported file, remove rows duplicates re-upload rows true duplicates. Now, get final deduplication results, use dedup_citations_add_manual()function. account additional duplicates reviewed, add additional_pairs argument. Now final set unique citations, can find new citations added latest systematic search? Lets also look citations identified searches removing citations single source. keep good records, don’t want lose track identifiers studies already included review. specifying citation keep important! illustrate , look specifically citations present old search. can check duplicate ids refer original record id existing_citations dataframe imported. can see, present. record_ids column can see different record_ids merged single citation. case make mistake don’t specify record_id keep duplicate_id, can use trace back citations original dataframes.","code":"potential_duplicates <- results$manual_dedup true_duplicates <- potential_duplicates final_results <- dedup_citations_add_manual(all_citations, additional_pairs = true_duplicates, merge_citations = TRUE, keep_source = \"old\") #> formatting data... #> identifying potential duplicates... #> identified duplicates! #> 8972 citations loaded... #> 489 duplicate citations removed... #> 8483 unique citations remaining! new_citations <- final_results %>%   filter(source == \"new\")   new_citations %>%    tail(3) %>%    gt::gt() %>%    gt::cols_hide(c(abstract)) crossover <- final_results %>%   filter(!source == \"new\") %>%   filter(!source == \"old\")   crossover %>%    tail(3) %>%    gt::gt() %>%    gt::cols_hide(c(abstract)) old_citations <- final_results %>%   filter(grepl(\"old\", source)) # find all citations in old search old_citations_check <- old_citations %>%   filter(duplicate_id %in% existing_search$record_id) #check that all citations use the OLD record_id as the duplicate_id  crossover %>%    tail(3) %>%    gt::gt() %>%    gt::cols_hide(c(abstract))"},{"path":"https://camaradesuk.github.io/ASySD/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kaitlyn Hair. Author, maintainer.","code":""},{"path":"https://camaradesuk.github.io/ASySD/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kaitlyn Hair, Zsanett Bahor, Malcolm Macleod,            Jing Liao, Emily S. Sena. (2021) Automated Systematic Search Deduplicator (ASySD):                  rapid, open-source, interoperable tool remove                  duplicate citations biomedical systematic reviews. bioRxiv. DOI 10.1101/2021.05.04.442412","code":"@Article{,   title = {The Automated Systematic Search Deduplicator (ASySD): a rapid, open-source,          interoperable tool to remove duplicate citations in biomedical systematic reviews.},   author = {Kaitlyn Hair and Zsanett Bahor and Malcolm Macleod and Jing Liao and Emily S Sena},   journal = {bioRxiv},   publisher = {Cold Spring Harbor Laboratory},   year = {2021},   doi = {10.1101/2021.05.04.442412}, }"},{"path":"https://camaradesuk.github.io/ASySD/index.html","id":"shiny-application","dir":"","previous_headings":"","what":"Shiny application","title":"Automated de-duplication of systematic searches","text":"tool available R package user-friendly shiny application.","code":""},{"path":"https://camaradesuk.github.io/ASySD/index.html","id":"tutorial","dir":"","previous_headings":"","what":"Tutorial","title":"Automated de-duplication of systematic searches","text":"Please check new ASySD tutorial youtube. like extend huge thank ESMARConf giving us platform showcase ASySD within evidence synthesis community!","code":""},{"path":"https://camaradesuk.github.io/ASySD/index.html","id":"tool-performance","dir":"","previous_headings":"","what":"Tool performance","title":"Automated de-duplication of systematic searches","text":"evaluation ASySD’s performance versus automated deduplication tools available preprint","code":""},{"path":"https://camaradesuk.github.io/ASySD/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation:","title":"Automated de-duplication of systematic searches","text":"","code":"install.packages(\"devtools\") devtools::install_github(\"camaradesuk/ASySD\")"},{"path":"https://camaradesuk.github.io/ASySD/index.html","id":"automatically-deduplicate-citation-data","dir":"","previous_headings":"","what":"Automatically deduplicate citation data","title":"Automated de-duplication of systematic searches","text":"","code":"# load citations  citation_data <- load_search(filepath, method=\"endnote\")  # deduplicate dedup_citations <- dedup_citations(citation_data)  # get unique citation dataframe unique_citations <- dedup_citations$unique"},{"path":"https://camaradesuk.github.io/ASySD/reference/add_id_citations.html","id":null,"dir":"Reference","previous_headings":"","what":"This function adds an id to citation data if missing — add_id_citations","title":"This function adds an id to citation data if missing — add_id_citations","text":"function adds id citation data missing","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/add_id_citations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function adds an id to citation data if missing — add_id_citations","text":"","code":"add_id_citations(raw_citations)"},{"path":"https://camaradesuk.github.io/ASySD/reference/add_id_citations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function adds an id to citation data if missing — add_id_citations","text":"raw_citations Citation dataframe relevant columns","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/add_id_citations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function adds an id to citation data if missing — add_id_citations","text":"Dataframe citations id","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations.html","id":null,"dir":"Reference","previous_headings":"","what":"This function deduplicates citation data — dedup_citations","title":"This function deduplicates citation data — dedup_citations","text":"function deduplicates citation data","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function deduplicates citation data — dedup_citations","text":"","code":"dedup_citations(   raw_citations,   manual_dedup = TRUE,   merge_citations = FALSE,   keep_source = NULL,   keep_label = NULL,   extra_merge_fields = NULL )"},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function deduplicates citation data — dedup_citations","text":"raw_citations dataframe containing duplicate ciations manual_dedup Logical value. want retrieve dataframe manual deduplication? merge_citations Logical value. want merge matching citations? keep_source Character vector. Selected citation source preferentially retain dataset unique record keep_label Selected citation label preferentially retain dataset unique record extra_merge_fields Add additional fields merge, output similar label, source, record_id columns commas merged value","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function deduplicates citation data — dedup_citations","text":"list 2 dataframes - unique citations citations manually deduplicated option selected","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations_add_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"This function deduplicates citation data — dedup_citations_add_manual","title":"This function deduplicates citation data — dedup_citations_add_manual","text":"function deduplicates citation data","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations_add_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function deduplicates citation data — dedup_citations_add_manual","text":"","code":"dedup_citations_add_manual(   raw_citations,   merge_citations = FALSE,   keep_source = NULL,   keep_label = NULL,   additional_pairs,   extra_merge_fields = NULL )"},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations_add_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function deduplicates citation data — dedup_citations_add_manual","text":"raw_citations dataframe containing duplicate citations merge_citations Logical value. want merge matching citations? keep_source Character vector. Selected citation source preferentially retain dataset unique record keep_label Selected citation label preferentially retain dataset unique record additional_pairs dataframe citations manual pairs, subset manual pairs export extra_merge_fields Add additional fields merge, output similar label, source, record_id columns commas merged value","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/dedup_citations_add_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function deduplicates citation data — dedup_citations_add_manual","text":"Unique citations post added manual deduplication","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/format_citations.html","id":null,"dir":"Reference","previous_headings":"","what":"This function formats citation data for deduplication — format_citations","title":"This function formats citation data for deduplication — format_citations","text":"function formats citation data deduplication","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/format_citations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function formats citation data for deduplication — format_citations","text":"","code":"format_citations(raw_citations)"},{"path":"https://camaradesuk.github.io/ASySD/reference/format_citations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function formats citation data for deduplication — format_citations","text":"raw_citations Citation dataframe relevant columns id column","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/format_citations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function formats citation data for deduplication — format_citations","text":"Dataframe formatted citations id","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/generate_dup_id.html","id":null,"dir":"Reference","previous_headings":"","what":"This function generates a duplicate ID for sets of matching citations — generate_dup_id","title":"This function generates a duplicate ID for sets of matching citations — generate_dup_id","text":"function generates duplicate ID sets matching citations","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/generate_dup_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function generates a duplicate ID for sets of matching citations — generate_dup_id","text":"","code":"generate_dup_id(true_pairs, formatted_citations)"},{"path":"https://camaradesuk.github.io/ASySD/reference/generate_dup_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function generates a duplicate ID for sets of matching citations — generate_dup_id","text":"true_pairs citation matches true duplicates' formatted_citations formatted citation data","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/generate_dup_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function generates a duplicate ID for sets of matching citations — generate_dup_id","text":"Dataframe formatted citation data duplicate id","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/identify_true_matches.html","id":null,"dir":"Reference","previous_headings":"","what":"This function identifies true pairs from matching pairs of citations and pairs which may be duplicates - for manual deduplication — identify_true_matches","title":"This function identifies true pairs from matching pairs of citations and pairs which may be duplicates - for manual deduplication — identify_true_matches","text":"function identifies true pairs matching pairs citations pairs may duplicates - manual deduplication","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/identify_true_matches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function identifies true pairs from matching pairs of citations and pairs which may be duplicates - for manual deduplication — identify_true_matches","text":"","code":"identify_true_matches(pairs)"},{"path":"https://camaradesuk.github.io/ASySD/reference/identify_true_matches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function identifies true pairs from matching pairs of citations and pairs which may be duplicates - for manual deduplication — identify_true_matches","text":"pairs citation matches may duplicates","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/identify_true_matches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function identifies true pairs from matching pairs of citations and pairs which may be duplicates - for manual deduplication — identify_true_matches","text":"Dataframe true citation pairs","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/keep_one_unique_citation.html","id":null,"dir":"Reference","previous_headings":"","what":"This function retains one citation in a set of matching records — keep_one_unique_citation","title":"This function retains one citation in a set of matching records — keep_one_unique_citation","text":"function retains one citation set matching records","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/keep_one_unique_citation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function retains one citation in a set of matching records — keep_one_unique_citation","text":"","code":"keep_one_unique_citation(   raw_citations,   matched_pairs_with_ids,   keep_source,   keep_label )"},{"path":"https://camaradesuk.github.io/ASySD/reference/keep_one_unique_citation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function retains one citation in a set of matching records — keep_one_unique_citation","text":"raw_citations original citation data ids matched_pairs_with_ids citation data duplicate ids keep_source Character vector. Selected citation source preferentially retain dataset unique record keep_label Selected citation label preferentially retain dataset unique record","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/keep_one_unique_citation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function retains one citation in a set of matching records — keep_one_unique_citation","text":"Dataframe citation data duplicate citation rows removed","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/load_multi_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Load in citations for deduplication — load_multi_search","title":"Load in citations for deduplication — load_multi_search","text":"function loads citation file within shiny app","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/load_multi_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load in citations for deduplication — load_multi_search","text":"","code":"load_multi_search(paths, names, method)"},{"path":"https://camaradesuk.github.io/ASySD/reference/load_multi_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load in citations for deduplication — load_multi_search","text":"paths Relative paths citations file files names File names input file files method Import method","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/load_multi_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load in citations for deduplication — load_multi_search","text":"dataframe citations","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/load_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Load in citations for deduplication — load_search","title":"Load in citations for deduplication — load_search","text":"function loads citations file.","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/load_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load in citations for deduplication — load_search","text":"","code":"load_search(path, method)"},{"path":"https://camaradesuk.github.io/ASySD/reference/load_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load in citations for deduplication — load_search","text":"path File path citations file method Import method","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/load_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load in citations for deduplication — load_search","text":"dataframe citations","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/match_citations.html","id":null,"dir":"Reference","previous_headings":"","what":"This function identifies matching pairs of citations — match_citations","title":"This function identifies matching pairs of citations — match_citations","text":"function identifies matching pairs citations","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/match_citations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function identifies matching pairs of citations — match_citations","text":"","code":"match_citations(formatted_citations)"},{"path":"https://camaradesuk.github.io/ASySD/reference/match_citations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function identifies matching pairs of citations — match_citations","text":"formatted_citations Formatted citation dataframe relevant columns id column","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/match_citations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function identifies matching pairs of citations — match_citations","text":"Dataframe citation pairs","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/merge_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"This function generates a duplicate ID for sets of matching citations — merge_metadata","title":"This function generates a duplicate ID for sets of matching citations — merge_metadata","text":"function generates duplicate ID sets matching citations","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/merge_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function generates a duplicate ID for sets of matching citations — merge_metadata","text":"","code":"merge_metadata(   raw_citations,   matched_pairs_with_ids,   keep_source,   keep_label,   extra_merge_fields )"},{"path":"https://camaradesuk.github.io/ASySD/reference/merge_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function generates a duplicate ID for sets of matching citations — merge_metadata","text":"raw_citations original citation data unique ids matched_pairs_with_ids citation data duplicate ids keep_source Character vector. Selected citation source preferentially retain dataset unique record keep_label Selected citation label preferentially retain dataset unique record extra_merge_fields Add additional fields merge, output similar label, source, record_id columns commas merged value","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/merge_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function generates a duplicate ID for sets of matching citations — merge_metadata","text":"Dataframe formatted citation data duplicate id","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/order_citations.html","id":null,"dir":"Reference","previous_headings":"","what":"This function orders citation data for deduplication — order_citations","title":"This function orders citation data for deduplication — order_citations","text":"function orders citation data deduplication","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/order_citations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function orders citation data for deduplication — order_citations","text":"","code":"order_citations(raw_citations)"},{"path":"https://camaradesuk.github.io/ASySD/reference/order_citations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function orders citation data for deduplication — order_citations","text":"raw_citations Citation dataframe relevant columns id column","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/order_citations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function orders citation data for deduplication — order_citations","text":"Dataframe ordered citations id","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations.html","id":null,"dir":"Reference","previous_headings":"","what":"This function writes citation data to disk in different formats — write_citations","title":"This function writes citation data to disk in different formats — write_citations","text":"function writes citation data disk different formats","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function writes citation data to disk in different formats — write_citations","text":"","code":"write_citations(citations, type = c(\"ris\", \"txt\", \"csv\", \"bib\"), filename)"},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function writes citation data to disk in different formats — write_citations","text":"citations dataframe containing citations - usually post-deduplication type export type filename output file name","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function writes citation data to disk in different formats — write_citations","text":"file export","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations_app.html","id":null,"dir":"Reference","previous_headings":"","what":"This function writes citation data to disk in different formats — write_citations_app","title":"This function writes citation data to disk in different formats — write_citations_app","text":"function writes citation data disk different formats","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function writes citation data to disk in different formats — write_citations_app","text":"","code":"write_citations_app(citations, type = c(\"ris\", \"txt\", \"csv\", \"bib\"), filename)"},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations_app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function writes citation data to disk in different formats — write_citations_app","text":"citations dataframe containing citations - usually post-deduplication type export type filename output file name","code":""},{"path":"https://camaradesuk.github.io/ASySD/reference/write_citations_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function writes citation data to disk in different formats — write_citations_app","text":"file export","code":""},{"path":"https://camaradesuk.github.io/ASySD/news/index.html","id":"asysd-010","dir":"Changelog","previous_headings":"","what":"ASySD 0.1.0","title":"ASySD 0.1.0","text":"Added NEWS.md file track changes package. Bug fix parallel processing errors (windows OS) CRAN preparation - small fixes ensure CMD check pass Added multi-search loading functions shiny app Added additional import options load_search() functions, including RIS Added documentation (user guide page) shiny app Enhanced error handling user messages Improved unit tests package stability","code":""}]
